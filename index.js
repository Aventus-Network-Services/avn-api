const { cryptoWaitReady } = require('@polkadot/util-crypto');
const { v4: uuidv4 } = require('uuid');
const Axios = require('axios');
const Query = require('./lib/query.js');
const Send = require('./lib/send.js');
const Poll = require('./lib/poll.js');
const Proxy = require('./lib/proxy.js');
const Awt = require('./lib/awt.js');
const Utils = require('./lib/utils.js');
const common = require('./lib/common.js');
const version = require('./package.json').version;

class AvnApi {
    static SetupMode = {
        SingleUser: 'singleUser',
        MultiUser: 'multiUser'
    };

    static SigningMode = {
        SuriBased: 'suriBased',
        RemoteSigner: 'remoteSigner'
    };

    constructor(gateway, options) {
        validateOptions(options)

        this.version = version;
        this.awtToken;
        this.gateway = gateway;
        this.utils = Utils;
        this.awt = Awt;
        this.proxy = Proxy;

        if (this.options.relayer) {
            common.validateAccount(this.options.relayer);
        }
    }
    async init() {
        await cryptoWaitReady();
        // TODO: do we want to allow changing SURI on the fly?
        const updateRemoteSignFunction = (signer) => {
            this.options.signer = {
                // to align with the sign function generated by the keyring, we only want to pass in a data parameter
                sign: (data) => signer.sign(data, signer.address),
                address: signer.address,
                publicKey: Utils.convertToPublicKeyBytes(signer.address)
            };
        };

        const setupSigner = async () => {
            this.options.suri = this.options.suri || process.env.AVN_SURI;

            const hasRemoteSigner = apiHasRemoteSigner(this.options);
            if (hasRemoteSigner === true) {
                updateRemoteSignFunction(this.options.signer);
            }

            if (!this.options.suri && !hasRemoteSigner) {
                throw new Error('Invalid signer. Please pass a SURI, set AVN_SURI environment variable or specify a remote signer');
            }
        };

        setupSigner();

        if (this.gateway) {
            const avnApi = {
                relayer: async (signer) => {
                    if (!this.relayer) {
                        this.relayer = this.options.relayer ? this.options.relayer : (await this.query(signer).getDefaultRelayer());
                    }
                    return this.relayer;
                },
                gateway: this.gateway,
                hasSplitFeeToken: () => this.hasSplitFeeToken(),
                uuid: () => uuidv4(),
                axios: async (signer) => {
                    if (!Awt.tokenAgeIsValid(this.awtToken)) {
                        console.log(' - Awt token has expired, refreshing');
                        this.awtToken = await Awt.generateAwtToken(this.options, signer);
                    }

                    // Add any middlewares here to configure global axios behaviours
                    Axios.defaults.headers.common = { Authorization: `bearer ${this.awtToken}` };
                    return Axios;
                }
            };

            if (this.options.setupMode === AvnApi.SetupMode.MultiUser) {
                const getSigner = (signerAddress) => {
                    return {
                        // to align with the sign function generated by the keyring, we only want to pass in a data parameter
                        sign: (data) => this.signer().sign(data, signerAddress),
                        address: signerAddress,
                        publicKey: Utils.convertToPublicKeyBytes(signerAddress)
                    };
                };

                this.query = (signerAddress) => new Query(avnApi, getSigner(signerAddress));
                this.send = (signerAddress) => new Send(avnApi, this.query, getSigner(signerAddress));
                this.poll = (signerAddress) => new Poll(avnApi, getSigner(signerAddress));
            } else {
                this.setSURI = async (suri) => {
                    if (!suri) throw new Error('Suri is a mandatory field');
                    this.options.suri = suri;
                    this.options.signer = undefined;
                    this.awtToken = this.gateway ? await Awt.generateAwtToken(this.options, this.signer()) : undefined;
                    console.info(' - Suri updated');
                };

                this.setSigner = async (signer) => {
                    if (!signer || !signer.address || typeof signer.sign !== 'function') {
                        throw new Error('Signer must be an object with a sign function and an address function');
                    }

                    this.options.suri = undefined;

                    updateRemoteSignFunction(signer);

                    this.awtToken = this.gateway ? await Awt.generateAwtToken(this.options, this.options.signer) : undefined;
                    console.info('\t - Signer updated');
                };

                this.signer = () => (apiHasRemoteSigner(this.options) ? this.options.signer : Utils.getSigner(this.options.suri));
                this.myAddress = () => this.signer().address;
                this.myPublicKey = () => Utils.convertToHexIfNeeded(this.signer().publicKey);

                //avnApi.signer = () => this.signer(),
                this.query = new Query(avnApi, this.signer());
                this.send = new Send(avnApi, this.query, this.signer());
                this.poll = new Poll(avnApi, this.signer());
            }
        }
    }
    initSingleUserMode() {
    }
    initMultiUserMode() {
    }

    hasSplitFeeToken() {
        if (!this.options) return false;
        if (this.options.hasPayer === true) return true;

        return !!this.options.payerAddress;
    }
}





function validateOptions(options) {
    if(!options) throw new Error("You must specify a setup mode and a signing mode")

    switch(options.signingMode) {
        case AvnApi.SigningMode.RemoteSigner:
            if(process.env.AVN_SURI || options.suri) {
                throw new Error("In remote signer mode, a suri must not be specified")
            }
            if(!apiHasRemoteSigner(options)) {
                throw new Error("In remote signer mode, you must specify a valid remote signer")
            }
            break;
        case AvnApi.SigningMode.SuriBased:
            if(options.signer) {
                throw new Error("In suri mode, a remote signer must not be specified")
            }
            if(!process.env.AVN_SURI && !options.suri) {
                throw new Error("In suri mode, you must specify a valid suri")
            }
            break;
        default:
            throw new Error("Signing mode must be defined")
    }

    switch(options.setupMode) {
        case AvnApi.SetupMode.SingleUser:
            break;
        case AvnApi.SetupMode.MultiUser:
            if(options.signingMode !== AvnApi.SigningMode.RemoteSigner) {
                throw new Error("In multi user mode, you must use a remote signer")
            }
            break;
        default:
            throw new Error("setup mode must be defined")
    }
}


function apiHasRemoteSigner(options) {
  if (!options.signer) return false;

  return !!options.signer.address && typeof options.signer.sign === 'function';
}

module.exports = AvnApi;
